#!/bin/sh
set -e
BASEDIR="$(cd "$(dirname "$0")" && pwd)"
cd "${BASEDIR}"

# Colors
Red="$(printf '\033[31m')"
Green="$(printf '\033[32m')"
Yellow="$(printf '\033[33m')"
Cyan="$(printf '\033[36m')"
Bold="$(printf '\033[1m')"
Dim="$(printf '\033[2m')"
Reset="$(printf '\033[0m')"

header() { printf "\n%b\n" "${Bold}${Cyan}$1${Reset}"; }
ok() { printf "%b\n" "${Green}✓ $1${Reset}"; }
warn() { printf "%b\n" "${Yellow}⚠ $1${Reset}"; }
run() {
    printf "%b\n" "${Dim}\$ $*${Reset}"
    "$@"
}
has() { command -v "$1" &>/dev/null; }
usage() {
    cat <<'EOF'
Usage: install [options] [dotbot args]

Options:
  -h, --help     Show this help and exit

Environment:
  NERDIFY=1      Enable Nerd Fonts patching for Consolas
EOF
}

for arg in "$@"; do
    case "$arg" in
        -h|--help)
            usage
            exit 0
            ;;
    esac
done
report_brew_bundle() {
    brewfile="$1"
    tmp_formula="$(mktemp)"
    tmp_cask="$(mktemp)"
    brew list --versions >"$tmp_formula"
    brew list --cask --versions >"$tmp_cask"

    while IFS= read -r line; do
        case "$line" in
        brew\ \"*\")
            name="${line#*\"}"
            name="${name%%\"*}"
            version="$(awk -v n="$name" '$1==n{print $2}' "$tmp_formula")"
            if [ -n "$version" ]; then
                ok "$name installed ($version)"
            else
                warn "$name not installed"
            fi
            ;;
        cask\ \"*\")
            name="${line#*\"}"
            name="${name%%\"*}"
            version="$(awk -v n="$name" '$1==n{print $2}' "$tmp_cask")"
            if [ -n "$version" ]; then
                ok "$name installed ($version)"
            else
                warn "$name not installed"
            fi
            ;;
        esac
    done <"$brewfile"

    rm -f "$tmp_formula" "$tmp_cask"
}

printf "\n%b\n" "${Bold}${Cyan}Dotfiles Installation${Reset}"

# System packages (Linux only)
if [ "$(uname)" = "Linux" ] && has apt; then
    has nala || {
        header "Installing nala..."
        sudo -v
        run sudo apt update
        run sudo apt install -y nala
    }
    # Check if key packages missing before running install
    if ! has zsh || ! has neovim || ! has jq; then
        header "Installing system packages..."
        sudo -v
        run sudo nala install -y build-essential gcc g++ make procps file \
            zsh bash git curl wget neovim htop tree jq python3 python3-pip \
            ddcutil i2c-tools
    else
        ok "System packages already installed"
    fi
fi

# Homebrew
if ! has brew; then
    header "Installing Homebrew..."
    bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
fi
# Source brew for this session
if [ "$(uname)" = "Darwin" ]; then
    eval "$(/opt/homebrew/bin/brew shellenv)"
else
    eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi
ok "Homebrew ready"

# Homebrew packages
if [ -f "${BASEDIR}/Brewfile" ]; then
    header "Installing Homebrew bundle..."
    run brew bundle --file "${BASEDIR}/Brewfile"
    header "Homebrew package versions"
    report_brew_bundle "${BASEDIR}/Brewfile"
else
    warn "Brewfile not found; skipping Homebrew bundle"
fi

# Rust
has rustc && ok "Rust already installed" || {
    header "Installing Rust..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    . "$HOME/.cargo/env"
}

# Bun
has bun && ok "Bun already installed" || {
    header "Installing Bun..."
    curl -fsSL https://bun.sh/install | bash
}

# Check Python/Node
has python3 && ok "Python installed" || warn "Python not found"
has node && ok "Node.js installed" || warn "Node.js not found (install via system packages or nvm)"

# Opencode
has opencode && ok "Opencode installed" || {
    header "Installing Opencode..."
    if has clang || has gcc; then
        run brew install anomalyco/tap/opencode
    else
        warn "Opencode needs a compiler (clang or gcc); install via system packages, then rerun"
    fi
}

# pre-commit
if has uv; then
    has pre-commit && ok "pre-commit installed" || {
        header "Installing pre-commit (uv)..."
        run uv tool install pre-commit
    }
else
    warn "uv not found; skipping pre-commit install"
fi

# Selawik font
FONT_URL="https://github.com/microsoft/Selawik/releases/download/1.01/Selawik_Release.zip"
if [ "$(uname)" = "Linux" ]; then
    FONT_DIR="$HOME/.local/share/fonts"
else
    FONT_DIR="$HOME/Library/Fonts"
fi
if fc-list 2>/dev/null | grep -q "Selawik"; then
    ok "Selawik font installed"
else
    header "Installing Selawik font..."
    mkdir -p "$FONT_DIR"
    TMP=$(mktemp -d)
    curl -sL "$FONT_URL" -o "$TMP/font.zip"
    unzip -q "$TMP/font.zip" -d "$TMP"
    find "$TMP" -name "*.otf" -o -name "*.ttf" | xargs -I{} cp {} "$FONT_DIR/"
    rm -rf "$TMP"
    has fc-cache && fc-cache -f
    ok "Selawik font installed"
fi

# Consolas fonts (ligaturized + nerdified)
CONSOLAS_REPO_URL="https://github.com/adityamwagh/consolas-nerd-font"
if [ "${NERDIFY:-}" = "1" ]; then
    CONSOLAS_VARIANT="Consolas LNF"
else
    CONSOLAS_VARIANT="Consolas L"
fi

CONSOLAS_TMP_DIR=""
if has git; then
    header "Fetching Consolas fonts..."
    CONSOLAS_TMP_DIR="$(mktemp -d)"
    run git clone --depth 1 "${CONSOLAS_REPO_URL}" "${CONSOLAS_TMP_DIR}"
else
    warn "git not found; skipping Consolas fonts"
fi

if [ -n "${CONSOLAS_TMP_DIR}" ]; then
    header "Installing ${CONSOLAS_VARIANT}..."
    mkdir -p "${FONT_DIR}"
    
    # Try the expected directory first
    CONSOLAS_OUT_DIR="${CONSOLAS_TMP_DIR}/${CONSOLAS_VARIANT}"
    FONTS_COPIED=0
    
    if [ -d "${CONSOLAS_OUT_DIR}" ]; then
        # Count how many TTF files we'll copy
        TTF_COUNT=$(find "${CONSOLAS_OUT_DIR}" -maxdepth 1 -name "*.ttf" 2>/dev/null | wc -l)
        if [ "$TTF_COUNT" -gt 0 ]; then
            find "${CONSOLAS_OUT_DIR}" -maxdepth 1 -name "*.ttf" -exec cp {} "${FONT_DIR}/" \;
            FONTS_COPIED=$TTF_COUNT
        fi
    else
        # If the specific directory doesn't exist, search the whole repo for TTF files
        warn "Directory ${CONSOLAS_VARIANT} not found, searching repository..."
        TTF_COUNT=$(find "${CONSOLAS_TMP_DIR}" -name "*.ttf" 2>/dev/null | wc -l)
        if [ "$TTF_COUNT" -gt 0 ]; then
            find "${CONSOLAS_TMP_DIR}" -name "*.ttf" -exec cp {} "${FONT_DIR}/" \;
            FONTS_COPIED=$TTF_COUNT
        fi
    fi
    
    # Check if any fonts were actually copied
    if [ "$FONTS_COPIED" -gt 0 ]; then
        has fc-cache && fc-cache -f
        ok "${CONSOLAS_VARIANT} installed ($FONTS_COPIED font$( [ "$FONTS_COPIED" -ne 1 ] && echo s))"
    else
        warn "No ${CONSOLAS_VARIANT} fonts found in repository"
    fi
fi

if [ -n "${CONSOLAS_TMP_DIR}" ]; then
    rm -rf "${CONSOLAS_TMP_DIR}"
fi

# Segoe UI (Linux)
if [ "$(uname)" = "Linux" ]; then
    SEGOE_URL="https://github.com/mrbvrz/segoe-ui-linux/archive/refs/heads/master.zip"
    if fc-list 2>/dev/null | grep -q "Segoe UI"; then
        ok "Segoe UI font installed"
    else
        header "Installing Segoe UI font..."
        mkdir -p "$FONT_DIR"
        TMP=$(mktemp -d)
        curl -sL "$SEGOE_URL" -o "$TMP/segoe.zip"
        unzip -q "$TMP/segoe.zip" -d "$TMP"
        find "$TMP" -name "*.otf" -o -name "*.ttf" | xargs -I{} cp {} "$FONT_DIR/"
        rm -rf "$TMP"
        has fc-cache && fc-cache -f
        ok "Segoe UI font installed"
    fi
fi

# Gruvbox Plus Icon Theme (Linux only)
if [ "$(uname)" = "Linux" ]; then
    ICONS_DIR="$HOME/.local/share/icons"
    GRUVBOX_ICONS_REPO="https://github.com/SylEleuth/gruvbox-plus-icon-pack.git"
    FOLDER_COLOR_SCRIPT_URL="https://github.com/SylEleuth/gruvbox-plus-icon-pack/releases/download/v6.2.0/folders-color-chooser.sh"
    
    if [ -d "$ICONS_DIR/Gruvbox-Plus-Dark" ] && [ -d "$ICONS_DIR/Gruvbox-Plus-Light" ]; then
        ok "Gruvbox Plus icons installed"
    else
        header "Installing Gruvbox Plus icon theme..."
        mkdir -p "$ICONS_DIR"
        TMP=$(mktemp -d)
        
        if git clone --depth 1 "$GRUVBOX_ICONS_REPO" "$TMP/gruvbox-plus" 2>/dev/null; then
            # Move icon themes to icons directory
            cp -r "$TMP/gruvbox-plus/Gruvbox-Plus-Dark" "$ICONS_DIR/"
            cp -r "$TMP/gruvbox-plus/Gruvbox-Plus-Light" "$ICONS_DIR/"
            
            # Download and run folder color chooser script to set green folders
            if curl -sL "$FOLDER_COLOR_SCRIPT_URL" -o "$ICONS_DIR/folders-color-chooser.sh"; then
                chmod +x "$ICONS_DIR/folders-color-chooser.sh"
                cd "$ICONS_DIR"
                ./folders-color-chooser.sh -c green >/dev/null 2>&1 || true
                cd "$BASEDIR"
            fi
            
            # Update icon cache
            has gtk-update-icon-cache && {
                gtk-update-icon-cache -f "$ICONS_DIR/Gruvbox-Plus-Dark" 2>/dev/null || true
                gtk-update-icon-cache -f "$ICONS_DIR/Gruvbox-Plus-Light" 2>/dev/null || true
            }
            
            ok "Gruvbox Plus icons installed (green folders)"
        else
            warn "Failed to clone Gruvbox Plus icons"
        fi
        
        rm -rf "$TMP"
    fi
fi

# Dotbot (symlinks)
header "Setting up symlinks..."
git -C dotbot submodule sync --quiet --recursive
git submodule update --init --recursive --remote dotbot
"${BASEDIR}/dotbot/bin/dotbot" -d "${BASEDIR}" -c "install.conf.yaml" "$@"

# --- Change default shell to zsh ---
if has zsh; then
    # Prefer system zsh over homebrew zsh for better root shell compatibility
    # Check for system zsh first (usually /usr/bin/zsh or /bin/zsh)
    if [ -f /usr/bin/zsh ]; then
        ZSH_PATH="/usr/bin/zsh"
    elif [ -f /bin/zsh ]; then
        ZSH_PATH="/bin/zsh"
    else
        # Fall back to whatever zsh is found in PATH (likely homebrew)
        ZSH_PATH="$(command -v zsh)"
        warn "Using homebrew zsh ($ZSH_PATH). Note: root shells may not have access to this."
    fi
    
    if [ "$(uname)" = "Linux" ]; then
        CURRENT_SHELL="$(getent passwd "$USER" | cut -d: -f7)"
    else
        # macOS
        CURRENT_SHELL="$(dscl . -read /Users/$USER UserShell 2>/dev/null | cut -d' ' -f2)"
    fi
    
    if [ "$CURRENT_SHELL" != "$ZSH_PATH" ]; then
        header "Changing default shell to zsh..."
        
        # On Linux, ensure the shell is in /etc/shells (required by chsh)
        SHELL_ADDED=true
        if [ "$(uname)" = "Linux" ] && [ -f /etc/shells ]; then
            if ! grep -Fxq "$ZSH_PATH" /etc/shells; then
                warn "Adding $ZSH_PATH to /etc/shells (requires sudo)..."
                if echo "$ZSH_PATH" | sudo tee -a /etc/shells >/dev/null 2>&1; then
                    ok "Added $ZSH_PATH to /etc/shells"
                else
                    warn "Failed to add shell to /etc/shells. Skipping shell change."
                    warn "You can manually add it with: echo '$ZSH_PATH' | sudo tee -a /etc/shells"
                    SHELL_ADDED=false
                fi
            fi
        fi
        
        # Only try to change shell if it was successfully added to /etc/shells (or on macOS)
        if [ "$SHELL_ADDED" = "true" ]; then
            warn "You may be prompted for your password."
            if chsh -s "$ZSH_PATH"; then
                ok "Default shell changed to zsh. Please log out and back in for changes to take effect."
            else
                warn "Failed to change default shell. You can change it manually later with: chsh -s $ZSH_PATH"
            fi
        fi
    else
        ok "zsh is already the default shell"
    fi
else
    warn "zsh is not installed. Skipping shell change."
fi

printf "\n%b\n\n" "${Bold}${Green}✓ Installation complete!${Reset}"
